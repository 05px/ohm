<html>
  <head>
    <title>ohm/js grammar viz demo</title>
    <meta charset=utf-8>
    <link href="viz.css" rel="stylesheet"></style>
    <script src="lib.js"></script>
    <script src="../dist/ohm.js"></script>
    <style>

body {
  position: relative;
}

col1,
col2 {
  display: inline-block;
  position: absolute;
  top: 0;
  bottom: 0;
  overflow: auto;
}

col1 {
  left: 0;
  right: 45%;
}

col2 {
  left: 55%;
  right: 0;
}

#source {
  width: 100%;
  height: 100%;
  font-family: Monaco;
  font-size: 11pt;
  outline: none;
  _border: none;
  border: 0;
  border-right: 2px dashed black;
  margin: 0;
  _margin-right: 5pt;
  resize: none;
}

#source.error {
  border-right: 2px dashed red;
}

#vizDiv {
  margin-left: 5pt;
}

    </style>
  </head>
  <body>
    <col1>
      <textarea id="source" cols="60" autofocus="true" spellcheck="false" wrap="off">
Arithmetic {
  Expr = AddExpr

  AddExpr
    = AddExpr '+' MulExpr -- plus
    | AddExpr '-' MulExpr -- minus
    | MulExpr

  MulExpr
    = MulExpr '*' ExpExpr -- times
    | MulExpr '/' ExpExpr -- divide
    | ExpExpr

  ExpExpr
    = PriExpr '^' ExpExpr -- power
    | PriExpr

  PriExpr
    = '(' Expr ')' -- paren
    | '+' PriExpr  -- pos
    | '-' PriExpr -- neg
    | ident
    | number

  ident -- identifier
    = letter alnum*

  number -- number literal
    = digit+ ('.' digit*)? -- integerAndFract
    | '.' digit+ -- onlyFract
}

      </textarea>
    </col1>
    <col2>
      <div id="vizDiv"></div>
    </col2>
    <script>

var curr = document.getElementById('vizDiv');

function enter(tag) {
  var child = makeElement(tag);
  curr.appendChild(child);
  curr = child;
}

function leave() {
  curr = curr.parentElement;
}

function addNode(node) {
  curr.appendChild(node);
}

function add(/* tagName, child1, child2, ... */) {
  addNode(makeElement.apply(this, arguments));
}

var viz = {
  Grammar:                  function(n, s, _, rs, _) {
                              enter('grammar');
                                add('name', n.value);
                                s.value;  // force evaluation
                                enter('rules');
                                  rs.value;  // force evaluation
                                leave();
                              leave();
                            },
  SuperGrammar:             function(expr) {
                              enter('super');
                                expr.value;  // force evaluation
                              leave();
                            },
  SuperGrammar_qualified:   function(_, ns, _, n) {
                              add('name', ns.value + '.' + n.value);
                            },
  SuperGrammar_unqualified: function(_, n) {
                              add('name', n.value);
                            },
  Rule:                     function(expr) {
                              enter('rule');
                                expr.value;  // force evaluation
                              leave();
                            },
  Rule_define:              function(n, d, _, b) {
                              add('name', n.value);
                              d.value;  // force evaluation
                              enter('ruleDefineBody');
                                b.value;  // force evaluation
                              leave();
                            },
  Rule_override:            function(n, _, b) {
                              add('name', n.value);
                              enter('ruleOverrideBody');
                                b.value;  // force evaluation
                              leave();
                            },
  Rule_extend:              function(n, _, b) {
                              add('name', n.value);
                              enter('ruleExtendBody');
                                b.value;  // force evaluation
                              leave();
                            },
  ruleDescr:                function(_, t, _) {
                              add('description', t.value);
                            },
  ruleDescrText:            function(_) {
                              return this.interval.contents;
                            },
  Alt:                      function(expr) {
                              expr.value;  // force evaluation
                            },
  Alt_rec:                  function(x, _, y) {
                              enter('alt');
                                enter('choice');
                                  x.value;  // force evaluation
                                leave();
                                enter('choice');
                                  y.value;  // force evaluation
                                leave();
                                if (curr.lastChild.children.length === 1 &&
                                    curr.lastChild.firstChild.tagName === 'ALT') {
                                  var alt = curr.lastChild.firstChild;
                                  curr.removeChild(curr.lastChild);
                                  while (alt.firstChild) {
                                    addNode(alt.firstChild);
                                  }
                                }
                              leave();
                            },
  Term:                     function(expr) {
                              expr.value;  // force evaluation
                            },
  Term_inline:              function(x, n) {
                              x.value;  // force evaluation
                              n.value;  // force evaluation
                            },
  caseName:                 function(_, _, n, _, _) {
                              add('description', n.value);
                            },
  Seq:                      function(expr) {
                              enter('seq');
                                expr.value;  // force evaluation
                              leave();
                            },
  Iter:                     function(expr) {
                              expr.value;  // force evaluation
                            },
  Iter_star:                function(x, _) {
                              enter('star');
                                x.value;  // force evaluation
                              leave();
                            },
  Iter_plus:                function(x, _) {
                              enter('plus');
                                x.value;  // force evaluation
                              leave();
                            },
  Iter_opt:                 function(x, _) {
                              enter('opt');
                                x.value;  // force evaluation
                              leave();
                            },
  Pred:                     function(expr) {
                              expr.value;  // force evaluation
                            },
  Pred_not:                 function(_, x) {
                              enter('not');
                                x.value;  // force evaluation
                              leave();
                            },
  Pred_lookahead:           function(_, x) {
                              enter('lookahead');
                                x.value;  // force evaluation
                              leave();
                            },
  Base:                     function(expr) {
                              expr.value;  // force evaluation
                            },
  Base_application:         function(ruleName) {
                              add('app', ruleName.value);
                            },
  Base_prim:                function(expr) {
                              expr.value;  // force evaluation
                            },
  Base_paren:               function(_, x, _) {
                              enter('paren');
                                x.value;  // force evaluation
                              leave();
                            },
  Base_listy:               function(_, x, _) {
                              enter('listy');
                                x.value;  // force evaluation
                              leave();
                            },
  Base_obj:                 function(_, lenient, _) {
                              throw 'TODO';
                            },
  Base_objWithProps:        function(_, ps, _, lenient, _) {
                              throw 'TODO';
                            },
  Props:                    function(expr) {
                              throw 'TODO';
                            },
  ident:                    function(n) {
                              return n.value;
                            },
  name:                     function(_, _) {
                              return this.interval.contents;
                            },
  string:                   function(_, cs, _) {
                              add('string', escape(eval(this.interval.contents)));
                            },
  regExp:                   function(_, e, _) {
                              e.value;  // force evaluation
                            },
  reCharClass:              function(_) {
                              add('charClass', this.interval.contents);
                            },
  number:                   function(_, _) {
                              add('prim', this.interval.contents);
                            },
  keyword:                  function(expr) {
                              expr.value;  // force evaluation
                            },
  keyword_undefined:        function(_) {
                              add('prim', 'undefined');
                            },
  keyword_null:             function(_) {
                              add('prim', 'null');
                            },
  keyword_true:             function(_) {
                              add('prim', 'true');
                            },
  keyword_false:            function(_) {
                              add('prim', 'false');
                            },
  sChar:                    function(_) {},
  Props_rec:                function(p, _, ps) {},
  Props_base:               function(p) {},
  Prop:                     function(n, _, p) {},
};

function escape(str) {
  var node = document.createElement('span');
  for (var idx = 0; idx < str.length; idx++) {
    if (str.charCodeAt(idx) < 32) {
      var c;
      switch (str.charAt(idx)) {
        case '\r':
          c = '\\r';
          break;
        case '\n':
          c = '\\n';
          break;
        case '\t':
          c = '\\t';
          break;
        default:
          c = '(ascii ' + str.charCodeAt(idx) + ')';
      }
      node.appendChild(makeElement('specialChar', c));
    } else {
      node.appendChild(document.createTextNode(str.charAt(idx)));
    }
  }
  return node;
}

var source = document.getElementById('source');
var vizDiv = document.getElementById('vizDiv');

source.oninput = function() {
  try {
    var thunk = ohm.ohmGrammar.matchContents(source.value, 'Grammar', true);
    removeChildren(vizDiv);
    thunk(viz);
    source.className = undefined;
  } catch (e) {
    console.log(e);
    source.className = 'error';
  }
};

source.oninput();

    </script>
  </body>
</html>

