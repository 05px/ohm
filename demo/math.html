<!doctype html>
<html>
  <head>
    <title>ohm/js math demo</title>
    <meta charset=utf-8>
    <link href="math.css" rel="stylesheet"></link>
    <script src="lib.js"></script>
    <script type="text/ohm-js">

Arithmetic {
  Expr
    = AddExpr

  AddExpr
    = AddExpr '+' MulExpr  -- plus
    | AddExpr '-' MulExpr  -- minus
    | MulExpr

  MulExpr
    = MulExpr '*' ExpExpr  -- times
    | MulExpr '/' ExpExpr  -- divide
    | ExpExpr

  ExpExpr
    = PriExpr '^' ExpExpr  -- power
    | PriExpr

  PriExpr
    = '(' Expr ')'  -- paren
    | '+' PriExpr   -- pos
    | '-' PriExpr   -- neg
    | ident
    | number

  ident  -- identifier
    = letter alnum*

  number  -- number
    = digit+ ('.' digit*)?  -- integerAndFract
    | '.' digit+            -- onlyFract
}

    </script>
  </head>
  <body>
    <input type="text" id="input" placeholder="Enter an arithmetic expression..." size="80"></input>
    <div id="errorDiv">
      <div id="spaces"></div>
      <wrapperWrapper><wrapper>
        <div id="error"><label>Expected: </label><span id="errorDetails"></span></div>
      </wrapper></wrapperWrapper>
    </div>
    <div id="value"></div>
    <div id="lisp"></div>
    <div id="tree"></div>
    <div id="twoD"></div>
    <script src="../dist/ohm.js"></script>
    <script>

var g = ohm.grammar("Arithmetic");

// ---------------------------------------------------------------------------------------------------------------------

var constants = {pi: Math.PI, e: Math.E};
var interpret = g.semanticAction({
  AddExpr_plus:   function(x, _, y) { return interpret(x) + interpret(y); },
  AddExpr_minus:  function(x, _, y) { return interpret(x) - interpret(y); },
  MulExpr_times:  function(x, _, y) { return interpret(x) * interpret(y); },
  MulExpr_divide: function(x, _, y) { return interpret(x) / interpret(y); },
  ExpExpr_power:  function(x, _, y) { return Math.pow(interpret(x), interpret(y)); },
  PriExpr_paren:  function(_, e, _) { return interpret(e); },
  PriExpr_pos:    function(_, e)    { return interpret(e); },
  PriExpr_neg:    function(_, e)    { return interpret(-e); },
  ident:          function(_, _)    { return constants[this.interval.contents]; },
  number:         function(_)       { return parseFloat(this.interval.contents); },
  _default:       ohm.actions.passThrough
});

// ---------------------------------------------------------------------------------------------------------------------

function stringify(x) {
  if (x instanceof Array) {
    var parts = [];
    for (var idx = 0; idx < x.length; idx++) {
      parts.push(stringify(x[idx]));
    }
    return "(" + parts.join(" ") + ")";
  } else {
    return x.toString();
  }
}

var toLisp = g.semanticAction({
  Expr:           function(e)       { return stringify(toLisp(e)); },
  AddExpr_plus:   function(x, _, y) { return ["+", toLisp(x), toLisp(y)]; },
  AddExpr_minus:  function(x, _, y) { return ["-", toLisp(x), toLisp(y)]; },
  MulExpr_times:  function(x, _, y) { return ["*", toLisp(x), toLisp(y)]; },
  MulExpr_divide: function(x, _, y) { return ["/", toLisp(x), toLisp(y)]; },
  ExpExpr_power:  function(x, _, y) { return ["pow", toLisp(x), toLisp(y)]; },
  PriExpr_paren:  function(_, e, _) { return toLisp(e); },
  PriExpr_pos:    function(_, e)    { return toLisp(e); },
  PriExpr_neg:    function(_, e)    { return ["neg", toLisp(e)]; },
  ident:          function(_, _)    { return this.interval.contents; },
  number:         function(_)       { return this.interval.contents; },
  _default:       ohm.actions.passThrough
});

// ---------------------------------------------------------------------------------------------------------------------

var toTree = g.semanticAction({
  Expr:           function(e)              { return makeElement("expr", toTree(e)); },
  AddExpr:        function(e)              { return makeElement("addExpr", toTree(e)); },
  AddExpr_plus:   function(x, op, y)       { return makeElement("plus", toTree(x), toTree(op), toTree(y)); },
  AddExpr_minus:  function(x, op, y)       { return makeElement("minus", toTree(x), toTree(op), toTree(y)); },
  MulExpr:        function(e)              { return makeElement("mulExpr", toTree(e)); },
  MulExpr_times:  function(x, op, y)       { return makeElement("times", toTree(x), toTree(op), toTree(y)); },
  MulExpr_divide: function(x, op, y)       { return makeElement("divide", toTree(x), toTree(op), toTree(y)); },
  ExpExpr:        function(e)              { return makeElement("expExpr", toTree(e)); },
  ExpExpr_power:  function(x, op, y)       { return makeElement("power", toTree(x), toTree(op), toTree(y)); },
  PriExpr:        function(e)              { return makeElement("priExpr", toTree(e)); },
  PriExpr_paren:  function(open, e, close) { return makeElement("paren", toTree(open), toTree(e), toTree(close)); },
  PriExpr_pos:    function(sign, e)        { return makeElement("pos", toTree(sign), toTree(e)); },
  PriExpr_neg:    function(sign, e)        { return makeElement("neg", toTree(sign), toTree(e)); },
  ident:          function(_, _)           { return makeElement("ident", this.interval.contents); },
  number:         function(_)              { return makeElement("number", this.interval.contents); },
  _terminal:      function(t)              { return t; }
});

// ---------------------------------------------------------------------------------------------------------------------

var toTwoD = g.semanticAction({
  AddExpr_plus:   function(x, op, y) { var operator = makeElement("operator", toTwoD(op));
                                       return makeElement("plus", toTwoD(x), operator, toTwoD(y)); },
  AddExpr_minus:  function(x, op, y) { var operator = makeElement("operator", "\u2212");
                                       return makeElement("minus", toTwoD(x), operator, toTwoD(y)); },
  MulExpr_times:  function(x, op, y) { var operator = makeElement("operator", "\u00D7");
                                       return makeElement("times", toTwoD(x), operator, toTwoD(y)); },
  MulExpr_divide: function(x, op, y) { var numerator = makeElement("numerator", toTwoD(x));
                                       var denominator = makeElement("denominator", toTwoD(y));
                                       return makeElement("fraction", numerator, denominator); },
  ExpExpr_power:  function(x, op, y) { var base = makeElement("theBase", toTwoD(x));
                                       var exponent = makeElement("exponent", toTwoD(y));
                                       return makeElement("power", base, exponent); },
  PriExpr_paren:  function(_, e, _)  { return makeElement("paren", toTwoD(e)); },
  PriExpr_pos:    function(sign, e)  { return makeElement("pos", toTwoD(sign), toTwoD(e)); },
  PriExpr_neg:    function(sign, e)  { return makeElement("neg", toTwoD(sign), toTwoD(e)); },
  ident:          function(_, _)     { var text = this.interval.contents;
                                       return makeElement("ident", text === "pi" ? "\u03C0" : text); },
  number:         function(_)        { return makeElement("number", this.interval.contents); },
  _terminal:      function(t)        { return t; },
  _default:       ohm.actions.passThrough
});

// ---------------------------------------------------------------------------------------------------------------------

var input = document.getElementById("input");
var spaces = document.getElementById("spaces");
var error = document.getElementById("error");
var errorDetails = document.getElementById("errorDetails");

input.value = "";
hideError();

input.oninput = function() {
  hideError();
  try {
    var cst = g.match(this.value, "Expr", true);
    this.className = undefined;
    show("value", interpret(cst));
    show("lisp", toLisp(cst));
    show("tree", toTree(cst));
    show("twoD", toTwoD(cst));
  } catch (e) {
    if (this.value.length === 0) {
      show("value", "");
      show("lisp", "");
      show("tree", "");
      show("twoD", "");
    } else {
      this.className = "error";
      showError(e);
    }
  }
};

function hideError() {
  errorDiv.className = errorDiv.className = "hidden";
}

function showError(e) {
  setTimeout(function() {
    // Position the error bubble to line up with the offending input
    spaces.innerHTML = repeat(" ", e.getPos());

    // Set up the details, i.e., what input was expected at that position
    removeChildren(errorDetails);
    e.getExpected().forEach(function(text, idx, expected) {
      var element = createExpectedElement(text);
      if (idx > 0) {
        errorDetails.appendChild(makeElement("light", idx === expected.length - 1 ? ", or " : ", "));
      }
      errorDetails.appendChild(element);
    });

    // Show error
    errorDiv.className = "visible";
  }, 0);
}

function createExpectedElement(s) {
  if (s.charAt(0) === '"' && s.charAt(s.length - 1) === '"' ||
      s.charAt(0) === "'" && s.charAt(s.length - 1) === "'") {
    return makeElement("literal",
      makeElement("light", '"'),
      makeElement("code", s.substr(1, s.length - 2)),
      makeElement("light", '"'));
  } else {
    return makeElement("description", s);
  }
}

    </script>
  </body>
</html>

