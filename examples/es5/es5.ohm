
// Copyright (C) 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// OMeta/JS parser for Ecmascript 5
// @author Tom Van Cutsem

// Adapted to Ohm by Tony Garnock-Jones <tonygarnockjones@gmail.com> 2014.

// abstract syntax trees (ASTs) are stored in JSONML format. For details see:
// http://code.google.com/p/es-lab/wiki/JsonMLASTFormat

ES5Parser {

  // A.1 Lexical Grammar

  // input characters are represented as ES3 characters, which can be any unicode character
  sourceCharacter = _

  empty =

  // // 7: Goal production in contexts where a leading "/" or "/=" is permitted
  // // Note: not used by the parser
  // InputElementDiv = whitespace | lineTerminator | comment | token | DivPunctuator

  // // 7: Goal production in contexts where a leading "/" or "/=' is not permitted
  // // Note: not used by the parser
  // InputElementRegExp = whitespace | lineTerminator | comment | token | regularExpressionLiteral

  // // Note: not currently used by the parser
  // token = identifierName | Punctuator | numericLiteral | stringLiteral

  // Override Ohm's built-in definition of space.
  space := (whitespace | lineTerminator /* whitespaceOrLineTerminator */ | comment)

  whitespace = /\p{SP}/ | /\p{TAB}/ | /\p{VT}/ | /\p{FF}/ | /\p{NBSP}/ | /\p{BOM}/ | /\p{Zs}/
  lineTerminator = /\p{LF}/ | /\p{CR}/ | /\p{LS}/ | /\p{PS}/
  lineTerminatorSequence = /\p{LF}/ | ~/\p{LF}/ /\p{CR}/ | /\p{LS}/ | /\p{PS}/
                         | /\p{CR}/ /\p{LF}/ -- crlf

  comment = multiLineComment | singleLineComment

  multiLineComment = "/*" (multiLineCommentChars | empty) "*/"
  multiLineCommentChars = multiLineNotAsteriskChar (multiLineCommentChars | empty)
                       | "*" (postAsteriskCommentChars | &"*/")
  postAsteriskCommentChars = multiLineNotForwardSlashOrAsteriskChar (multiLineCommentChars | empty)
                          | "*" (postAsteriskCommentChars | &"*/")
  multiLineNotAsteriskChar = ~("*") sourceCharacter
  multiLineNotForwardSlashOrAsteriskChar = ~("/" | "*") sourceCharacter
  singleLineComment = "//" (~lineTerminator sourceCharacter)*

  identifier = ~reservedWord identifierName
  identifierName = identifierStart identifierPart*

  identifierStart = unicodeLetter | "$" | "_"
                  | "\\" unicodeEscapeSequence -- escaped
  identifierPart = identifierStart | unicodeCombiningMark
                 | unicodeDigit | unicodeConnectorPunctuation
                 | /\p{ZWNJ}/ | /\p{ZWJ}/
  unicodeLetter = /\p{L}/ | /\p{Nl}/
  unicodeCombiningMark = /\p{Mn}/ | /\p{Mc}/
  unicodeDigit = /\p{Nd}/
  unicodeConnectorPunctuation = /\p{Pc}/

  reservedWord = keyword | futureReservedWord | nullLiteral | booleanLiteral

  // Note: keywords that are the complete prefix of another keyword should
  // be prioritized (e.g. 'in' should come before 'instanceof')
  keyword = ("break"   | "do"        | "instanceof" | "typeof"
          | "case"     | "else"      | "new"        | "var"
          | "catch"    | "finally"   | "return"     | "void"
          | "continue" | "for"       | "switch"     | "while"
          | "debugger" | "function"  | "this"       | "with"
          | "default"  | "if"        | "throw"
          | "delete"   | "in"        | "try") ~identifierPart

  futureReservedWordLax = ("class"| "enum"  | "extends"
                        | "super" | "const" | "export"
                        | "import" ) ~identifierPart
  futureReservedWordStrict = (futureReservedWordLax
                           |  "implements"| "let"     | "private"   | "public"
                           |  "interface" | "package" | "protected" | "static"
                           |  "yield" ) ~identifierPart
  futureReservedWord = futureReservedWordStrict

  // Note: beware of the ordering of punctuators with a common prefix!
  // OMeta is a PEG, so "|" denotes prioritized choice.
  // E.g. if "+" would come before "++" then the string "++5"
  // would be parsed as "+(+(5))" rather than "++(5)"
  // Punctuators comprised of more characters are prioritized
  // Note: the Punctuator and DivPunctuator rules are not currently used by the parser
  // Punctuator = (">>>="
  //            | ">>=" | ">>>" | "===" | "!=="| "<<="
  //            | "+="  | "-="  | "*="  | "%=" | ">="
  //            | "=="  | "!="  | "++"  | "--" | "<<"
  //            | ">>"  | "<="  | "&="  | "|=" | "^="
  //            | "&&"  | "||"
  //            | "{"     | "}"     | "("     | ")"    | "["   | "]"
  //            | "."     | ";"     | ","     | "<"    | ">"   | "!"
  //            | "~"     | "="     | "&"     | "|"    | "^"   | "?"
  //            | ":"     | "*"     | "%"     | "+"    | "-")
  // DivPunctuator = ("/=" | "/")

  literal = nullLiteral | booleanLiteral | numericLiteral
          | stringLiteral | regularExpressionLiteral // spec forgot Regexp literals in appendix?
  nullLiteral = "null"
  booleanLiteral = "true" | "false"

  // For semantics on how decimal literals are constructed, see section 7.8.3

  // Note that the ordering of hexIntegerLiteral and decimalLiteral is reversed w.r.t. the spec
  // This is intentional: the order decimalLiteral | hexIntegerLiteral will parse
  // "0x..." as a decimal literal "0" followed by "x..."
  numericLiteral = hexIntegerLiteral | decimalLiteral

  decimalLiteral = decimalIntegerLiteral "." decimalDigit* exponentPart -- bothParts
                 |                       "." decimalDigit* exponentPart -- decimalsOnly
                 | decimalIntegerLiteral                   exponentPart -- integerOnly

  decimalIntegerLiteral = nonZeroDigit (decimalDigit* | empty) -- nonZero
                        | "0"                                  -- zero
  decimalDigit = /[0123456789]/
  nonZeroDigit = /[123456789]/

  exponentPart = exponentIndicator signedInteger -- present
               |                                 -- absent
  exponentIndicator = "e" | "E"
  signedInteger = "+" decimalDigit* -- positive
                | "-" decimalDigit* -- negative
                |     decimalDigit+ -- noSign

  hexIntegerLiteral = "0x" hexDigit*
                    | "0X" hexDigit*

  // For semantics on how string literals are constructed, see section 7.8.4
  stringLiteral = """ doubleStringCharacter* """
                | "'" singleStringCharacter* "'"
  doubleStringCharacter = ~("\"" | "\\" | lineTerminator) sourceCharacter -- nonEscaped
                        | "\\" escapeSequence                             -- escaped
                        | lineContinuation                                -- lineContinuation
  singleStringCharacter = ~("'" | "\\" | lineTerminator) sourceCharacter -- nonEscaped
                        | "\\" escapeSequence                            -- escaped
                        | lineContinuation                               -- lineContinuation
  lineContinuation = "\\" lineTerminatorSequence
  escapeSequence = characterEscapeSequence
                 | ~decimalDigit "0" // -> ( String.fromCharCode(0000) ) /*\u0000*/
                 | hexEscapeSequence
                 | unicodeEscapeSequence
  characterEscapeSequence = singleEscapeCharacter
                          | nonEscapeCharacter
  singleEscapeCharacter = "'"  // -> ( String.fromCharCode(0039) ) /*\u0027*/
                        | "\"" // -> ( String.fromCharCode(0034) ) /*\u0022*/
                        | "\\" // -> ( String.fromCharCode(0092) ) /*\u005C*/
                        | "b"  // -> ( String.fromCharCode(0008) ) /*\u0008*/
                        | "f"  // -> ( String.fromCharCode(0012) ) /*\u000C*/
                        | "n"  // -> ( String.fromCharCode(0010) ) /*\u000A*/
                        | "r"  // -> ( String.fromCharCode(0013) ) /*\u000D*/
                        | "t"  // -> ( String.fromCharCode(0009) ) /*\u0009*/
                        | "v"  // -> ( String.fromCharCode(0011) ) /*\u000B*/
  nonEscapeCharacter = ~(escapeCharacter | lineTerminator) sourceCharacter
  escapeCharacter = singleEscapeCharacter | decimalDigit | "x" | "u"
  hexEscapeSequence = "x" hexDigit hexDigit
  unicodeEscapeSequence = "u" hexDigit hexDigit hexDigit hexDigit

  // section 7.8.5

  // body and flags are left uninterpreted while parsing (they are parsed as strings)
  regularExpressionLiteral = "/" regularExpressionBody "/" regularExpressionFlags
  regularExpressionBody = regularExpressionFirstChar regularExpressionChar*
  regularExpressionFirstChar = ~("*" |"\\" | "/" | "[") regularExpressionNonTerminator
                             | regularExpressionBackslashSequence
                             | regularExpressionClass
  regularExpressionChar = ~("\\" | "/" | "[") regularExpressionNonTerminator
                        | regularExpressionBackslashSequence
                        | regularExpressionClass
  regularExpressionBackslashSequence = "\\" regularExpressionNonTerminator
  regularExpressionNonTerminator = ~(lineTerminator) sourceCharacter
  regularExpressionClass = "[" regularExpressionClassChar* "]"
  regularExpressionClassChar = ~("]" | "\\") regularExpressionNonTerminator
                             | regularExpressionBackslashSequence
  regularExpressionFlags = identifierPart*

  // === Implementation-level rules (not part of the spec) ===

  multiLineCommentNoNL = "/*" (multiLineCommentCharsNoNL | empty) "*/"
  multiLineCommentCharsNoNL = multiLineNotAsteriskCharNoNL (multiLineCommentCharsNoNL | empty)
                           | "*" postAsteriskCommentCharsNoNL
  postAsteriskCommentCharsNoNL = multiLineNotForwardSlashOrAsteriskCharNoNL (multiLineCommentCharsNoNL | empty)
                              | "*" postAsteriskCommentCharsNoNL
  multiLineNotAsteriskCharNoNL = ~("*") ~lineTerminator sourceCharacter
  multiLineNotForwardSlashOrAsteriskCharNoNL = ~("/" | "*") ~lineTerminator sourceCharacter

  // see section 14.1: Directive Prologues and the Use Strict Directive
  // Some directives (like the Use Strict Directive) may require access to the
  // raw string value, without interpretation of escapeSequences or lineContinuations
  // @returns the raw string value (not a String Literal AST)
  rawStringLiteral = "\"" (~"\"" sourceCharacter)* "\""
                  | "'" (~"'" sourceCharacter)* "'"

  // used by parser to parse actual tokens

  skip = space*

  // does not accept lineTerminators, not even implicit ones in a multiLineComment (cf. section 7.4)
  skipNoLine = (whitespace | singleLineComment | multiLineCommentNoNL)*

  skipToEnd = skip end

  // a semicolon is "automatically inserted" if a newline is reached
  // the end of the input stream is reached, or the offending token is "}"
  // Note: don't use ";" as this is equivalent to token(";")
  // which would allow line terminators to be eaten as well
  sc = skipNoLine ";"
     | skipNoLine (scanLineTerminator | end | &"}")

  // All rules starting with 'scan' skip whitespace, then scan the appropriate tokens

  scanLineTerminator = lineTerminator | ~multiLineCommentNoNL multiLineComment

  scanPunctNoLineTerminatorPP = skipNoLine "++"
  scanPunctNoLineTerminatorMM = skipNoLine "--"

  // @returns a string
  scanIdentifier = skip identifier

  // @returns a string
  scanIdentifierName = skip identifierName

  // @returns a string
  scanIdentifierNoLineTerminator = skipNoLine identifier

  // @returns a literal token
  scanLiteral = skip literal

  // @returns an object {value: string, directive: string}
  // where 'value' contains the interpreted string value
  // and 'directive' contains the uninterpreted ('raw') string value
  scanDirective = skip &(rawStringLiteral) stringLiteral

  // ========== end of the lexer ==========


  // === ECMAScript 5 Parser ===

  // A.3 Expressions

  // @returns an AST
  PrimaryExpression = "this"                       -- thisExpr
                    | scanIdentifier               -- idExpr
                    | scanLiteral
                      // ( litToken.type === "regexp"
                      //   ? this.ast(_fromIdx, "RegExpExpr",{body:  litToken.value.body
                      //                            flags: litToken.value.flags}, [])
                      //   : this.ast(_fromIdx, "LiteralExpr",{type:  litToken.type
                      //                             value: litToken.value}, []) )
                    | ArrayLiteral
                    | ObjectLiteral
                    | "(" Expression ")"         -- parenExpr

  // @returns an ArrayExpr AST
  ArrayLiteral = "[" AssignmentExpressionOrElisionComma* "]" -- trailingComma
               | "[" AssignmentExpressionOrElisionComma* AssignmentExpression "]" -- noTrailingComma
  AssignmentExpressionOrElisionComma = (AssignmentExpression | Elision) ","
  Elision =

  // @returns an ObjectExpr AST
  ObjectLiteral = "{" PropertyAssignmentComma* "}" -- trailingComma
                | "{" PropertyAssignmentComma* PropertyAssignment "}" -- noTrailingComma
  PropertyAssignmentComma = PropertyAssignment ","

  // @returns a *Prop AST
  PropertyAssignment = "get" PropertyName "(" ")" "{" FunctionBody "}"                 -- getter
                     | "set" PropertyName "(" FormalParameter ")" "{" FunctionBody "}" -- setter
                     | PropertyName ":" AssignmentExpression                           -- simple

  // @returns a string
  PropertyName = scanIdentifierName
               | stringLiteral
               | numericLiteral

  // @returns an AST
  MemberExpression = "new" MemberExpression Arguments         -- newExp
                   | MemberExpression "[" Expression "]"      -- arrayRefExp
                   | MemberExpression "." scanIdentifierName  -- propRefExp
                   | FunctionExpression
                   | PrimaryExpression

  // @returns an AST
  NewExpression = MemberExpression
                | "new" NewExpression -- newExp

  // @returns an AST
  CallExpression = CallExpression "[" Expression "]"     -- arrayRefExp
                 | CallExpression "." scanIdentifierName -- propRefExp
                 | CallExpression Arguments              -- callExpExp
                 | MemberExpression Arguments            -- memberExpExp

  // @returns an array of ASTs
  Arguments = "(" ")"                -- empty
            | "(" ArgumentList ")"   -- nonEmpty

  // @returns an array of ASTs
  ArgumentList = AssignmentExpressionComma* AssignmentExpression -- many
               | AssignmentExpression                            -- one

  AssignmentExpressionComma = AssignmentExpression ","

  LeftHandSideExpression = CallExpression
                         | NewExpression

  PostfixExpression = LeftHandSideExpression scanPunctNoLineTerminatorPP -- postIncrement
                    | LeftHandSideExpression scanPunctNoLineTerminatorMM -- postDecrement
                    | LeftHandSideExpression

  UnaryExpression = "delete"   UnaryExpression     -- deleteExp
                  | "void"     UnaryExpression     -- voidExp
                  | "typeof"   UnaryExpression     -- typeofExp
                  | "++"          UnaryExpression  -- preIncrement
                  | "--"          UnaryExpression  -- preDecrement
                  | "+" UnaryExpression            -- unaryPlus
                  | "-" UnaryExpression            -- unaryMinus
                  | "~" UnaryExpression            -- bnot
                  | "!" UnaryExpression            -- lnot
                  | PostfixExpression

  MultiplicativeExpression = MultiplicativeExpression "*" UnaryExpression -- mul
                           | MultiplicativeExpression "/" UnaryExpression -- div
                           | MultiplicativeExpression "%" UnaryExpression -- mod
                           | UnaryExpression

  AdditiveExpression = AdditiveExpression "+" MultiplicativeExpression -- add
		     | AdditiveExpression "-" MultiplicativeExpression -- sub
		     | MultiplicativeExpression

  ShiftExpression = ShiftExpression "<<" AdditiveExpression  -- lsl
                  | ShiftExpression ">>>" AdditiveExpression -- lsr
                  | ShiftExpression ">>" AdditiveExpression  -- asr
                  | AdditiveExpression

  // Ohm doesn't support parameterized rules, but we don't want to
  // duplicate our expression-parsing rules. Instead, we're
  // experimenting with just permitting 'x in y' expressions *even in
  // contexts where they're illegal*, and rejecting them in a
  // post-parse-pass. A little like rejecting unbound variables in a
  // postpass, or implementing a type checker.

  RelationalExpression =
      RelationalExpression "<" ShiftExpression           -- lt
    | RelationalExpression ">" ShiftExpression           -- gt
    | RelationalExpression "<=" ShiftExpression          -- le
    | RelationalExpression ">=" ShiftExpression          -- ge
    | RelationalExpression "instanceof" ShiftExpression  -- instanceOfExp
    | RelationalExpression "in" ShiftExpression          -- inExp
    | ShiftExpression

  EqualityExpression =
      EqualityExpression "==" RelationalExpression  -- equal
    | EqualityExpression "!=" RelationalExpression  -- notEqual
    | EqualityExpression "===" RelationalExpression -- eq
    | EqualityExpression "!==" RelationalExpression -- notEq
    | RelationalExpression

  BitwiseANDExpression = BitwiseANDExpression "&" EqualityExpression -- band
		       | EqualityExpression

  BitwiseXORExpression = BitwiseXORExpression "^" BitwiseANDExpression -- bxor
		       | BitwiseANDExpression

  BitwiseORExpression = BitwiseORExpression "|" BitwiseXORExpression -- bor
		      | BitwiseXORExpression

  LogicalANDExpression = LogicalANDExpression "&&" BitwiseORExpression -- land
		       | BitwiseORExpression

  LogicalORExpression = LogicalORExpression "||" LogicalANDExpression -- lor
		      | LogicalANDExpression

  ConditionalExpression = LogicalORExpression "?"
                            AssignmentExpression ":" AssignmentExpression -- conditional
                        | LogicalORExpression

  AssignmentExpression = LeftHandSideExpression
                           AssignmentOperator AssignmentExpression -- assignment
                       | ConditionalExpression

  Expression = Expression "," AssignmentExpression -- commaExp
             | AssignmentExpression

  AssignmentOperator = "=" | ">>>=" | "<<=" | ">>="
                     | "*=" | "/=" | "%=" | "+=" | "-=" | "&=" | "^=" | "|="

  // A.4 Statements

  Statement = Block
            | VariableStatement
            | EmptyStatement
            | ExpressionStatement
            | IfStatement
            | IterationStatement
            | ContinueStatement
            | BreakStatement
            | ReturnStatement
            | WithStatement
            | LabelledStatement
            | SwitchStatement
            | ThrowStatement
            | TryStatement
            | DebuggerStatement

  // @returns a Block AST
  // Note: the ES5 spec prescribes that a block is a StatementList, not a SourceElement list
  // this precludes nested function declarations
  // This parser explicitly deviates from the spec to enable nested function declarations
  Block = "{" SourceElement* "}"

  // StatementList = Statement*

  // @returns a Var AST
  VariableStatement = "var" VariableDeclarationList sc

  // @returns an array of ASTs
  VariableDeclarationList = VariableDeclarationComma* VariableDeclaration -- many
                          | VariableDeclaration

  VariableDeclarationComma = VariableDeclaration ","

  // @returns an AST
  VariableDeclaration = InitPattern -- initialValue
                      | IdPattern -- noInitialValue

  // @returns an AST
  InitPattern = IdPattern Initialiser

  // @returns an AST
  IdPattern = scanIdentifier

  // @returns an AST
  Initialiser = "=" AssignmentExpression

  // @returns an AST
  EmptyStatement = ";" // note: this semicolon eats newlines

  // @returns an Expression AST
  ExpressionStatement = ~("{" | "function") Expression sc

  // @returns an AST
  IfStatement = "if" "(" Expression ")" Statement "else" Statement -- ifThenElse
              | "if" "(" Expression ")" Statement                  -- ifThen

  // @returns an AST
  IterationStatement = "do" Statement "while" "(" Expression ")" sc     -- doWhile
                     | "while" "(" Expression ")" Statement             -- whileDo
                     | "for" "(" (Expression | empty) ";"
                                 (Expression | empty) ";"
                                 (Expression | empty) ")" Statement     -- for3
                     | "for" "(" "var" VariableDeclarationList ";"
                                 (Expression | empty) ";"
                                 (Expression | empty) ")" Statement     -- for3var
                     | "for" "(" LeftHandSideExpression "in"
                                 Expression ")" Statement               -- forIn
                     | "for" "(" "var" VariableDeclaration "in"
                                 Expression ")" Statement               -- forInVar

  ContinueStatement = "continue" sc                                 -- unlabelled
                    | "continue" scanIdentifierNoLineTerminator sc  -- labelled

  BreakStatement = "break" sc                                 -- unlabelled
                 | "break" scanIdentifierNoLineTerminator sc  -- labelled

  ReturnStatement = "return" sc                        -- returnVoid
                  | "return" skipNoLine Expression sc  -- returnExpr

  WithStatement = "with" "(" Expression ")" Statement

  SwitchStatement = "switch" "(" Expression ")" CaseBlock

  // @return an array of ASTs
  CaseBlock = "{" CaseClause* DefaultClause CaseClause* "}"  -- withDefault
            | "{"                           CaseClause* "}"  -- withoutDefault

  CaseClause = "case" Expression ":" Statement*

  DefaultClause = "default" ":" Statement*

  LabelledStatement = scanIdentifier ":" Statement

  ThrowStatement = "throw" skipNoLine
                              scanLineTerminator ~empty // fails explicitly
                   // TODO: what on earth is this rule for?
                                             -- throwShouldNeverMatch
                 | "throw" Expression sc   -- throwExpr

  TryStatement = "try" Block Catch Finally  -- tryCatchFinally
               | "try" Block Finally        -- tryFinally
               | "try" Block Catch          -- tryCatch

  // @returns a CatchClause AST
  Catch = "catch" "(" FormalParameter ")" Block

  // @returns a Block AST
  Finally = "finally" Block

  DebuggerStatement = "debugger" sc


  // A.5 Functions and Programs

  FunctionDeclaration = "function" IdPattern
                        "(" FormalParameterList ")"
                        "{" FunctionBody "}"

  FunctionExpression = "function" IdPattern
                       "(" FormalParameterList ")"
                       "{" FunctionBody "}"                                 -- named
                     | "function" "(" FormalParameterList ")"
                       "{" FunctionBody "}"                                 -- anonymous

  // @returns an array of ASTs
  FormalParameterList = FormalParameter (CommaFormalParameter)* -- many
                      |                                         -- zero

  CommaFormalParameter = "," FormalParameter

  // @returns an AST
  FormalParameter = IdPattern

  // @returns an array of ASTs
  FunctionBody = Directive* SourceElement*

  Program = Directive* SourceElement* skipToEnd

  SourceElement = Declaration | Statement

  // Broken out so es6 can override to include ConstDecl and LetDecl
  Declaration = FunctionDeclaration

  Directive = scanDirective sc

  // === Implementation-level rules (not part of the spec) ===

  // useful for parsing only expressions and making sure the parser sees all input
  ExpressionOnly = Expression skipToEnd
}

ES5ParserLax <: ES5Parser {
  futureReservedWord := futureReservedWordLax
}
