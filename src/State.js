'use strict';

// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

var PosInfo = require('./PosInfo');
var Trace = require('./Trace');
var pexprs = require('./pexprs');

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

var applySpaces_ = new pexprs.Apply('spaces_');

function State(grammar, inputStream, startRule, tracingEnabled) {
  this.grammar = grammar;
  this.origInputStream = inputStream;
  this.startRule = startRule;
  this.tracingEnabled = tracingEnabled;
  this.rightmostFailPos = -1;
  this.init();
}

State.prototype = {
  init: function(optRecordFailures) {
    this.inputStreamStack = [];
    this.posInfosStack = [];
    this.pushInputStream(this.origInputStream);
    this.applicationStack = [];
    this.inLexifiedContextStack = [false];
    this.bindings = [];
    if (optRecordFailures) {
      this.failures = [];
    }
    this.doNotRecordFailuresCount = 0;  // should not record failures if this is > 0
    if (this.isTracing()) {
      this.trace = [];
    }
  },

  enter: function(app) {
    this.applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
  },

  exit: function() {
    this.applicationStack.pop();
    this.inLexifiedContextStack.pop();
  },

  enterLexifiedContext: function() {
    this.inLexifiedContextStack.push(true);
  },

  exitLexifiedContext: function() {
    this.inLexifiedContextStack.pop();
  },

  currentApplication: function() {
    return this.applicationStack[this.applicationStack.length - 1];
  },

  inSyntacticRule: function() {
    if (typeof this.inputStream.source !== 'string') {
      return false;
    }
    var currentApplication = this.currentApplication();
    return currentApplication && currentApplication.isSyntactic();
  },

  inSyntacticContext: function() {
    return this.inSyntacticRule() && !this.inLexifiedContext();
  },

  inLexifiedContext: function() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },

  skipSpaces: function() {
    this.doNotRecordFailures();
    applySpaces_.eval(this);
    this.bindings.pop();
    this.doRecordFailures();
    return this.inputStream.pos;
  },

  skipSpacesIfInSyntacticContext: function() {
    if (this.inSyntacticContext()) {
      this.skipSpaces();
    }
    return this.inputStream.pos;
  },

  truncateBindings: function(newLength) {
    while (this.bindings.length > newLength) {
      this.bindings.pop();
    }
  },

  pushInputStream: function(inputStream) {
    this.inputStreamStack.push(this.inputStream);
    this.posInfosStack.push(this.posInfos);
    this.inputStream = inputStream;
    this.posInfos = [];
  },

  popInputStream: function() {
    this.inputStream = this.inputStreamStack.pop();
    this.posInfos = this.posInfosStack.pop();
  },

  getCurrentPosInfo: function() {
    return this.getPosInfo(this.inputStream.pos);
  },

  getPosInfo: function(pos) {
    var posInfo = this.posInfos[pos];
    return posInfo || (this.posInfos[pos] = new PosInfo(this));
  },

  recordFailure: function(pos, expr) {
    if (this.doNotRecordFailuresCount > 0) {
      return;
    } else if (this.failures) {
      // only interested in failures at the rightmost position that haven't already been recorded
      if (pos === this.rightmostFailPos &&
          !this.failures.some(function(failure) { return failure.expr === expr; })) {
        this.failures.push({expr: expr, fluffy: false});
      }
    } else {
      // this.failures === undefined, i.e., we're still trying to find out what the rightmost error
      // position is.
      if (pos > this.rightmostFailPos) {
        // new rightmost failure!
        this.rightmostFailPos = pos;
      }
    }
  },

  doNotRecordFailures: function() {
    this.doNotRecordFailuresCount++;
  },

  doRecordFailures: function() {
    this.doNotRecordFailuresCount--;
  },

  getFailuresPos: function() {
    return this.rightmostFailPos;
  },

  getFailures: function(optIncludeFluffy) {
    if (!this.failures) {
      // Rewind, then try to match the input again, recording failures.
      this.init(true);
      this.tracingEnabled = false;
      var succeeded = new pexprs.Apply(this.startRule).eval(this);
      if (succeeded) {
        this.failures = [];
      }
    }

    var fs = this.failures;
    if (!optIncludeFluffy) {
      fs = fs.filter(function(f) { return !f.fluffy; });
    }
    return fs.map(function(f) { return f.expr; });
  },

  getAllFailures: function() {
    return this.getFailures(true);
  },

  // Returns the memoized trace entry for `pos` and `expr`, if one exists.
  getMemoizedTraceEntry: function(pos, expr) {
    var posInfo = this.posInfos[pos];
    if (posInfo && expr.ruleName) {
      var memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec) {
        return memoRec.traceEntry;
      }
    }
    return null;
  },

  // Make a new trace entry, using the currently active trace array as the
  // new entry's children.
  getTraceEntry: function(pos, expr, result) {
    var entry = this.getMemoizedTraceEntry(pos, expr);
    if (!entry) {
      entry = new Trace(this.inputStream, pos, expr, result, this.trace);
    }
    return entry;
  },

  isTracing: function() {
    return this.tracingEnabled;
  },

  applySpaces_: applySpaces_
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = State;
