// --------------------------------------------------------------------
// Imports
// --------------------------------------------------------------------

var Interval = require('./Interval.js');
var PosInfo = require('./PosInfo.js');

// --------------------------------------------------------------------
// Private stuff
// --------------------------------------------------------------------

function State(grammar, inputStream, tracingEnabled) {
  this.grammar = grammar;
  this.inputStreamStack = [];
  this.posInfosStack = [];
  this.pushInputStream(inputStream);
  this.ruleStack = [];
  this.bindings = [];
  this.failureDescriptor = this.makeFailureDescriptor();
  if (tracingEnabled) {
    this.trace = [];
  }
}

State.prototype = {
  pushInputStream: function(inputStream) {
    this.inputStreamStack.push(this.inputStream);
    this.posInfosStack.push(this.posInfos);
    this.inputStream = inputStream;
    this.posInfos = [];
  },

  popInputStream: function() {
    this.inputStream = this.inputStreamStack.pop();
    this.posInfos = this.posInfosStack.pop();
  },

  getCurrentPosInfo: function() {
    return this.getPosInfo(this.inputStream.pos);
  },

  getPosInfo: function(pos) {
    var posInfo = this.posInfos[pos];
    return posInfo || (this.posInfos[pos] = new PosInfo(this.ruleStack));
  },

  recordFailure: function(pos, expr) {
    if (pos < this.failureDescriptor.pos) {
      // Failure is not at the right-most position -- ignore it.
      return;
    } else if (pos > this.failureDescriptor.pos) {
      // Drop the old failures -- this is the new right-most position.
      this.failureDescriptor.pos = pos;
      this.failureDescriptor.exprs = [expr];
    } else {
      // Another failure at right-most position -- record it if it wasn't already.
      if (this.failureDescriptor.exprs.indexOf(expr) < 0) {
        this.failureDescriptor.exprs.push(expr);
      }
    }
  },

  recordFailures: function(failureDescriptor) {
    var self = this;
    failureDescriptor.exprs.forEach(function(expr) {
      self.recordFailure(failureDescriptor.pos, expr);
    });
  },

  getFailuresPos: function() {
    return this.failureDescriptor.pos;
  },

  makeFailureDescriptor: function() {
    // TODO: use a Map for exprs, once it's available (the shims don't help because they're O(1))
    return {pos: -1, exprs: []};
  },

  // Make a new trace entry, using the currently active trace array as the
  // new entry's children.
  makeTraceEntry: function(pos, expr, ans) {
    var entry = {
      displayString: expr.ruleName || (expr.obj ? "'" + expr.obj + "'" : null),
      pos: pos,
      expr: expr,
      succeeded: ans,
      children: this.trace
    };
    if (ans) {
      entry.interval = new Interval(this.inputStream, pos, this.inputStream.pos);
    }
    return entry;
  },

  isTracing: function() {
    return !!this.trace;
  }
};

// --------------------------------------------------------------------
// Exports
// --------------------------------------------------------------------

module.exports = State;

